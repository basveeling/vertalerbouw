group stil;
typeFieldMap ::= [
    "int":"I",
    "bool":"Z",
    "char":"Ljava/lang/String;"
]
logic_operators ::= [
  "lt" :"if_icmplt",
  "lte":"if_icmple",
  "gt" :"if_icmpgt",
  "gte":"if_icmpge",
  "eq" :"if_icmpeq",
  "neq":"if_icmpne"
]

program(maxStackDepth, maxLocals, instructions) ::= <<
  .class public Program
  .super java/lang/Object
  .method public \<init>()V
    aload_0
    invokenonvirtual java/lang/Object/\<init>()V
    return
  .end method

  .method public static main([Ljava/lang/String;)V
    .limit stack 102
    .limit locals 100
    <instructions ; separator="\npop\n">
    pop
    return
  .end method
>>

compound_expression(instructions) ::= <<
  <instructions ; separator="\npop\n">
>>

becomes(varnum, expression, id, type) ::= <<
  <expression>
  dup
  istore <varnum> ; <type> <id>
>>

idOperand(id, varnum, type) ::= <<
  iload <varnum> ; <type> <id>
>>


charLiteral(value) ::= <<
  ldc "<value>"
>>


intLiteral(value) ::= <<
  ldc <value>
>>


divide(expr1, expr2) ::= <<
  <expr1>
  <expr2>
  idiv
>>


minus(expr1, expr2) ::= <<
  <expr1>
  <expr2>
  isub
>>

logic_expr(expr1,expr2,label1,label2,operator) ::= <<
  <expr1>
  <expr2>
  <logic_operators.(operator)> L<label1>
  ldc 0
  goto L<label2>
  L<label1>:
  ldc 1 
  L<label2>:
>>

not(expr1) ::= <<
  <expr1>
  ifeq
>>


modulo(expr1, expr2) ::= <<
  <expr1>
  <expr2>
  irem
>>


multiply(expr1, expr2) ::= <<
  <expr1>
  <expr2>
  imul
>>


plus(expr1, expr2) ::= <<
  <expr1>
  <expr2>
  iadd
>>


unary_minus(expr1) ::= <<
  <expr1>
  ineg
>>


unary_plus(expr1) ::= <<
  <expr1>
>>

print(expression,type) ::= <<
  <expression>
  dup
  getstatic java/lang/System/out Ljava/io/PrintStream; 
  swap
  invokevirtual java/io/PrintStream/println(<typeFieldMap.(type)>)V
>>

printMultiple(statements) ::= <<
  <statements ; separator="\npop\n">
>>