group stil;

type_map ::= [
  "int"  : "I",
  "bool" : "Z",
  "char" : "C"
]

bool_map ::= [
  "true"  : "1",
  "false" : "0"
]

logic_operators ::= [
  "lt"  : "if_icmplt",
  "lte" : "if_icmple",
  "gt"  : "if_icmpgt",
  "gte" : "if_icmpge",
  "eq"  : "if_icmpeq",
  "neq" : "if_icmpne"
]

program(maxStackDepth, maxLocals, instructions) ::= <<
  .class public Program
  .super java/lang/Object
  .method public \<init>()V
    aload_0
    invokenonvirtual java/lang/Object/\<init>()V
    return
  .end method

  .method public static main([Ljava/lang/String;)V
    .limit stack 102
    .limit locals 100
    <instructions ; separator="\npop\n">
    pop
    return
  .end method
>>


and(expr1, expr2) ::= <<
<expr1>
<expr2>
iand
>>


compound_expression(instructions) ::= <<
<instructions ; separator="\npop\n">
>>


becomes(varnum, expression, id, type) ::= <<
<expression>
dup
istore <varnum> ; <type> <id>
>>


idOperand(id, varnum, type) ::= <<
iload <varnum> ; <type> <id>
>>


boolLiteral(value) ::= <<
bipush <bool_map.(value)>
>>


charLiteral(value) ::= <<
bipush <value>
>>


comparison(expr1, expr2, label1, label2, operator) ::= <<
<expr1>
<expr2>
<logic_operators.(operator)> L<label1>
bipush 0
goto L<label2>
L<label1>:
bipush 1 
L<label2>:
>>


intLiteral(value) ::= <<
bipush <value>
>>


divide(expr1, expr2) ::= <<
<expr1>
<expr2>
idiv
>>


minus(expr1, expr2) ::= <<
<expr1>
<expr2>
isub
>>


not(expr, label1, label2) ::= <<
<expr>
ifeq L<label1>
bipush 0
goto L<label2>
L<label1>:
bipush 1 
L<label2>:
>>


or(expr1, expr2) ::= <<
<expr1>
<expr2>
ior
>>


modulo(expr1, expr2) ::= <<
<expr1>
<expr2>
irem
>>


multiply(expr1, expr2) ::= <<
<expr1>
<expr2>
imul
>>


plus(expr1, expr2) ::= <<
<expr1>
<expr2>
iadd
>>


unary_minus(expr1) ::= <<
<expr1>
ineg
>>


unary_plus(expr1) ::= <<
<expr1>
>>


print(expression,type) ::= <<
<expression>
dup
getstatic java/lang/System/out Ljava/io/PrintStream; 
swap
invokevirtual java/io/PrintStream/println(<type_map.(type)>)V
>>


printMultiple(statements) ::= <<
<statements ; separator="\npop\n">
>>


read(label, varnum) ::= <<
new java/util/Scanner
dup
getstatic java/lang/System/in Ljava/io/InputStream;
invokespecial java/util/Scanner/\<init>(Ljava/io/InputStream;)V
astore_1 ; scanner
iconst_0
istore_2 ; result
aload_1 ; scanner
invokevirtual java/util/Scanner/hasNextInt()Z
ifeq L<label>
aload_1 ; scanner
invokevirtual java/util/Scanner/nextInt()I
istore_2 ; result
L<label>:
aload_1 ; scanner
invokevirtual java/util/Scanner/close()V
getstatic java/lang/System/out Ljava/io/PrintStream;
iload_2 ; result
dup
istore <varnum>
>>


readMultiple(statements) ::= <<
<statements ; separator="\npop\n">
>>